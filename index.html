<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>草薙京：火柴人補給生存戰</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        canvas { display: block; background: #333; margin: 0 auto; /* 背景色在JS中繪製 */ }
        .ui-layer { position: fixed; top: 15px; left: 15px; pointer-events: none; color: white; text-shadow: 2px 2px #000; z-index: 10; }
        .hp-bar-bg { width: 220px; height: 18px; background: #333; border: 2px solid #fff; margin-top: 5px; border-radius: 9px; overflow: hidden; }
        .hp-bar-fill { width: 100%; height: 100%; background: linear-gradient(to right, #ff416c, #ff4b2b); transition: width 0.3s; }
        .controls { position: fixed; bottom: 20px; left: 10px; right: 10px; display: flex; justify-content: space-between; pointer-events: auto; z-index: 10; }
        .btn { width: 60px; height: 60px; background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; user-select: none; font-weight: bold; -webkit-tap-highlight-color: transparent; }
        .d-pad { display: grid; grid-template-columns: repeat(3, 65px); gap: 10px; }
        #btnAttack { width: 80px; height: 80px; background: rgba(211, 84, 0, 0.7); border-color: #ff9d00; position: relative; overflow: hidden; font-size: 18px; }
        #cd-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0,0,0,0.5); }
        .status-msg { color: #00ffff; font-weight: bold; margin-top: 5px; height: 20px; }
    </style>
</head>
<body>

<div class="ui-layer">
    <div style="color: #ffcc00; font-size: 22px; font-weight: bold;">K.O. : <span id="kill-count">0</span></div>
    <div class="hp-bar-bg"><div id="hp-fill" class="hp-bar-fill"></div></div>
    <div id="status-text" class="status-msg"></div>
</div>

<canvas id="gameCanvas"></canvas>

<div class="controls">
    <div class="d-pad">
        <div style="grid-column: 2;" class="btn" id="btnJump">↑</div>
        <div style="grid-column: 1; grid-row: 2;" class="btn" id="btnLeft">←</div>
        <div style="grid-column: 2; grid-row: 2;" class="btn" id="btnDown">↓</div>
        <div style="grid-column: 3; grid-row: 2;" class="btn" id="btnRight">→</div>
    </div>
    <div class="btn" id="btnAttack">大蛇薙<div id="cd-overlay"></div></div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = 400;

// 遊戲狀態
let player = { 
    x: 100, y: 300, w: 30, h: 60, dy: 0, speed: 5, 
    hp: 100, jumping: false, crouching: false, ground: 290, 
    invincible: 0, frame: 0, frameTick: 0, dir: 1, moving: false,
    rapidFire: 0 // 連發剩餘時間
};
let flames = []; 
let enemies = [];
let items = []; // 補充包
let kills = 0;
let cameraX = 0;
let keys = {};
let attackCD = 0;
let spawnTimer = 0;
let itemSpawnTimer = 0;

// 控制監聽
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

function setupBtn(id, key) {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
}
setupBtn('btnLeft', 'ArrowLeft'); setupBtn('btnRight', 'ArrowRight');
setupBtn('btnJump', 'ArrowUp'); setupBtn('btnDown', 'ArrowDown');

document.getElementById('btnAttack').addEventListener('touchstart', (e) => { e.preventDefault(); handleAttack(); });
window.addEventListener('keydown', e => { if(e.code === 'Space') handleAttack(); });

function handleAttack() {
    if (attackCD <= 0) {
        flames.push({ 
            x: player.x + (player.dir === 1 ? 20 : -60), 
            y: player.crouching ? player.y + 25 : player.y + 15, 
            w: 55, h: 25, speed: 15 * player.dir, dir: player.dir 
        });
        attackCD = (player.rapidFire > 0) ? 10 : 100; // 連發模式下 CD 縮短
    }
}

function spawnItem() {
    items.push({
        x: cameraX + Math.random() * canvas.width + 200,
        y: -50,
        type: Math.random() > 0.5 ? 'HP' : 'SPEED',
        speed: 1.5
    });
}

function update() {
    // 玩家狀態
    player.moving = false;
    player.crouching = keys['ArrowDown'] && !player.jumping;

    if (!player.crouching) {
        if (keys['ArrowRight']) { player.x += player.speed; player.dir = 1; player.moving = true; }
        if (keys['ArrowLeft'] && player.x > cameraX) { player.x -= player.speed; player.dir = -1; player.moving = true; }
    }
    if (keys['ArrowUp'] && !player.jumping && !player.crouching) { player.dy = -15; player.jumping = true; }

    player.dy += 0.8;
    player.y += player.dy;
    if (player.y > player.ground) { player.y = player.ground; player.dy = 0; player.jumping = false; }

    cameraX = player.x - 150;

    // 動畫計時
    if (player.moving && !player.jumping) {
        player.frameTick++;
        if (player.frameTick > 6) { player.frame = (player.frame + 1) % 4; player.frameTick = 0; }
    } else {
        player.frame = player.jumping ? 4 : (player.crouching ? 5 : 0); // 新增蹲下幀 5
    }

    // CD 與 道具狀態
    if (attackCD > 0) attackCD -= 2.5;
    document.getElementById('cd-overlay').style.height = attackCD + "%";
    if (player.rapidFire > 0) {
        player.rapidFire--;
        document.getElementById('status-text').innerText = "連發模式中!!";
    } else {
        document.getElementById('status-text').innerText = "";
    }

    // 火焰邏輯
    flames.forEach((f, fi) => {
        f.x += f.speed;
        enemies.forEach((e, ei) => {
            if (f.x < e.x + e.w && f.x + f.w > e.x && f.y < e.y + e.h && f.y + f.h > e.y) {
                enemies.splice(ei, 1);
                kills++; document.getElementById('kill-count').innerText = kills;
            }
        });
        if (Math.abs(f.x - player.x) > 800) flames.splice(fi, 1);
    });

    // 補充包邏輯
    items.forEach((it, idx) => {
        it.y += it.speed;
        if (player.x < it.x + 30 && player.x + 30 > it.x && player.y < it.y + 30 && player.y + 60 > it.y) {
            if (it.type === 'HP') player.hp = Math.min(100, player.hp + 30);
            else player.rapidFire = 300; // 約 5 秒
            items.splice(idx, 1);
        }
        if (it.y > 400) items.splice(idx, 1);
    });

    // 怪物與道具生成
    if (++spawnTimer > Math.max(15, 50 - Math.floor(kills/10))) {
        let type = Math.random() > 0.4 ? 'snake' : 'tiger';
        enemies.push({ x: cameraX + canvas.width + 100, y: type === 'snake' ? 330 : 305, w: 40, h: 20, type: type, speed: 2+Math.random()*4 });
        spawnTimer = 0;
    }
    if (++itemSpawnTimer > 400) { spawnItem(); itemSpawnTimer = 0; }

    // 傷害判定
    if (player.invincible > 0) player.invincible--;
    enemies.forEach((e) => {
        e.x -= e.speed;
        // 判定火柴人身體部位
        let playerHitboxY = player.y + (player.crouching ? 30 : 0); // 蹲下時 Y 座標提高
        let playerHitboxH = player.h - (player.crouching ? 30 : 0); // 蹲下時高度減少

        if (player.x < e.x + e.w && player.x + player.w > e.x && playerHitboxY < e.y + e.h && playerHitboxY + playerHitboxH > e.y) {
            if (player.invincible <= 0) {
                player.hp -= 20; player.invincible = 50;
                if (player.hp <= 0) { alert("戰鬥失敗！K.O.數: " + kills); location.reload(); }
            }
        }
    });
    document.getElementById('hp-fill').style.width = player.hp + "%";
    if (player.x > 8000) { alert("草薙京成功擊退百鬼，抵達城堡！K.O.數: " + kills); location.reload(); }
}

function drawStickman() {
    ctx.strokeStyle = (player.rapidFire > 0) ? '#00ffff' : '#fff';
    ctx.lineWidth = 4; ctx.lineCap = 'round';
    ctx.save();
    ctx.translate(player.x + 15, player.y + 30);
    if (player.dir === -1) ctx.scale(-1, 1);

    // 火柴人身體部位的 Y 軸偏移量
    let headYOffset = -25;
    let bodyYOffset = -15;
    let armFootYOffset = 15;
    let legYOffset = 30;

    if (player.crouching) {
        headYOffset = 5;
        bodyYOffset = 10;
        armFootYOffset = 20;
        legYOffset = 35; // 腿更彎曲
    }

    // 頭部
    ctx.beginPath(); ctx.arc(0, headYOffset, 10, 0, Math.PI*2); ctx.stroke();
    // 身體
    ctx.beginPath(); ctx.moveTo(0, bodyYOffset); ctx.lineTo(0, armFootYOffset); ctx.stroke();

    // 手與腳 動畫
    let f = player.frame;
    ctx.beginPath();
    if (player.crouching) { // 蹲下姿勢
        ctx.moveTo(0, bodyYOffset + 5); ctx.lineTo(15, armFootYOffset + 10); ctx.moveTo(0, bodyYOffset + 5); ctx.lineTo(-15, armFootYOffset + 10); // 手臂
        ctx.moveTo(0, armFootYOffset + 5); ctx.lineTo(15, legYOffset); ctx.moveTo(0, armFootYOffset + 5); ctx.lineTo(-15, legYOffset); // 腿
    } else if (f === 0) { // 靜止
        ctx.moveTo(0, -10); ctx.lineTo(10, 5); ctx.moveTo(0, -10); ctx.lineTo(-10, 5); // 手
        ctx.moveTo(0, 15); ctx.lineTo(8, 30); ctx.moveTo(0, 15); ctx.lineTo(-8, 30); // 腳
    } else if (f === 1 || f === 3) { // 走路跨步
        let offset = f === 1 ? 15 : -15;
        ctx.moveTo(0, -10); ctx.lineTo(offset, 5); ctx.moveTo(0, -10); ctx.lineTo(-offset, 5);
        ctx.moveTo(0, 15); ctx.lineTo(offset, 30); ctx.moveTo(0, 15); ctx.lineTo(-offset, 30);
    } else if (f === 4) { // 跳躍
        ctx.moveTo(0, -10); ctx.lineTo(15, -5); ctx.moveTo(0, -10); ctx.lineTo(-15, -5);
        ctx.moveTo(0, 15); ctx.lineTo(10, 10); ctx.moveTo(0, 15); ctx.lineTo(-10, 10);
    } else { // 中間過渡
        ctx.moveTo(0, -10); ctx.lineTo(5, 10); ctx.moveTo(0, -10); ctx.lineTo(-5, 10);
        ctx.moveTo(0, 15); ctx.lineTo(5, 30); ctx.moveTo(0, 15); ctx.lineTo(-5, 30);
    }
    ctx.stroke();
    ctx.restore();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();

    // 繪製背景 (不跟隨攝影機移動)
    ctx.fillStyle = '#1a1a2e'; // 天空深藍
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 繪製遠景山脈 (慢速捲動)
    ctx.fillStyle = '#2c3e50'; // 深藍灰色山脈
    let mountainScrollX = -cameraX * 0.2; // 0.2倍速捲動
    ctx.beginPath();
    ctx.moveTo(mountainScrollX + 0, 200);
    ctx.lineTo(mountainScrollX + 100, 150);
    ctx.lineTo(mountainScrollX + 250, 220);
    ctx.lineTo(mountainScrollX + 400, 160);
    ctx.lineTo(mountainScrollX + 550, 210);
    ctx.lineTo(mountainScrollX + canvas.width + 100, 200);
    ctx.lineTo(mountainScrollX + canvas.width + 100, 400);
    ctx.lineTo(mountainScrollX + 0, 400);
    ctx.fill();
    // 讓山脈無限重複
    ctx.beginPath();
    ctx.moveTo(mountainScrollX + canvas.width + 0, 200);
    ctx.lineTo(mountainScrollX + canvas.width + 100, 150);
    ctx.lineTo(mountainScrollX + canvas.width + 250, 220);
    ctx.lineTo(mountainScrollX + canvas.width + 400, 160);
    ctx.lineTo(mountainScrollX + canvas.width + 550, 210);
    ctx.lineTo(mountainScrollX + canvas.width * 2 + 100, 200);
    ctx.lineTo(mountainScrollX + canvas.width * 2 + 100, 400);
    ctx.lineTo(mountainScrollX + canvas.width + 0, 400);
    ctx.fill();

    // 地平線
    ctx.fillStyle = '#b0b0b0'; // 淺灰色地平線
    ctx.fillRect(0, 240, canvas.width, 5); // 畫在地平線的 Y 軸位置

    // 應用攝影機移動到遊戲元素
    ctx.translate(-cameraX, 0);

    // 補充包
    items.forEach(it => {
        ctx.fillStyle = it.type === 'HP' ? '#ff0000' : '#00aaff';
        ctx.fillRect(it.x, it.y, 30, 30);
        ctx.fillStyle = '#fff'; ctx.font = "16px Arial";
        ctx.fillText(it.type === 'HP' ? "H" : "S", it.x+8, it.y+22);
    });

    // 火焰大蛇薙
    flames.forEach(f => {
        ctx.fillStyle = '#ffcc00'; ctx.shadowBlur = 20; ctx.shadowColor = '#ff4500';
        ctx.fillRect(f.dir === 1 ? f.x : f.x - f.w, f.y, f.w, f.h);
        ctx.shadowBlur = 0;
    });

    // 繪製主角 (受傷閃爍)
    if (player.invincible % 10 < 5) drawStickman();

    // 繪製怪物
    enemies.forEach(e => {
        ctx.fillStyle = e.type === 'snake' ? '#2ecc71' : '#e74c3c';
        ctx.fillRect(e.x, e.y, e.w, e.h);
        ctx.fillStyle = '#fff'; ctx.fillRect(e.x+5, e.y+5, 6, 6); // 眼睛
    });

    // 繪製近景森林地面 (快速捲動)
    ctx.fillStyle = '#3a5f0b'; // 深綠色地面
    ctx.fillRect(cameraX, 350, canvas.width, 50);

    // 城堡
    ctx.fillStyle = '#444';
    ctx.fillRect(8000, 150, 160, 200);

    ctx.restore();
    update();
    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
